COMPUTATION spmv
  map(0, rows, i, ov[i],
      dot(rowstr[i], rowstr[i+1], j,
          a[j], iv[colidx[j]]))

HARNESS cuda IMPLEMENTS spmv
  double alpha = 1.0;
  double beta  = 0.0;
  cusparseMatDescr_t descrA;
  cusparseCreateMatDescr(&descrA);
  cusparseDcsrmv(handle,
                 CUSPARSE_OPERATION_NON_TRANSPOSE,
                 rows, cols, rowstr[rows], &alpha,
                 descrA, d_a, d_rowstr, d_colidx,
                 d_iv, &beta, d_ov);
TRANSFORMATIONS
  int cols      = Maximum of colidx[0..rowstr[rows]]
  double* d_a   = CudaRead of a[0..rowstr[rows]]
  double* d_iv  = CudaRead of iv[0..cols]
  int* d_rowstr = CudaRead of rowstr[0..rows+1]
  int* d_colidx = CudaRead of colidx[0..rowstr[rows]]
  double* d_ov  = CudaWrite of ov[0..rows]
CONTEXT
  cusparseHandle_t handle
CONSTRUCTION
  cusparseCreate(&handle);
DESTRUCTION
  cusparseDestroy(handle);
HEADER
  #include <cuda_runtime.h>
  #include "cusparse_v2.h"

HARNESS mkl IMPLEMENTS spmv
  sparse_matrix_t A;
  mkl_sparse_d_create_csr(&A, SPARSE_INDEX_BASE_ZERO,
                          rows, cols, rowstr,
                          rowstr+1, colidx, a);
  struct matrix_descr dscr;
  dscr.type = SPARSE_MATRIX_TYPE_GENERAL;
  dscr.mode = SPARSE_FILL_MODE_LOWER;
  dscr.diag = SPARSE_DIAG_NON_UNIT;
  mkl_sparse_d_mv(SPARSE_OPERATION_NON_TRANSPOSE,
                  1.0, A, dscr, iv, 0.0, ov);
TRANSFORMATIONS
  int cols = Maximum of colidx[0 .. rowstr[rows]]
HEADER
  #include "mkl.h"

READABLE CudaRead
  cudaMemcpy(out, in, sizeof(type_in)*size,
             cudaMemcpyHostToDevice);
CONSTRUCTION
  cudaMalloc(&out, sizeof(type_in)*size);
DESTRUCTION
  cudaFree(out);

WRITEABLE CudaWrite
  cudaMemcpy(in, out, sizeof(type_in)*size,
             cudaMemcpyDeviceToHost);
CONSTRUCTION
  cudaMalloc(&out, sizeof(type_in)*size);
DESTRUCTION
  cudaFree(out);

READABLE Maximum
  out = in[0];
  for(int i = 1; i < size; i++)
    out = in[i]>out?in[i]:out;
  out = out+1;
