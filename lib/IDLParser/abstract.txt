COMPUTATION spmv_csr
  forall(0 <= i < rows) {
    output[i] = sum(ranges[i] <= j < ranges[i+1])
            matrix[j] * vector[indir[j]];
  }

HARNESS cuda IMPLEMENTS spmv_csr
  double alpha = 1.0;
  double beta  = 0.0;
  cusparseMatDescr_t descrA;
  cusparseCreateMatDescr(&descrA);
  cusparseDcsrmv(handle,
                 CUSPARSE_OPERATION_NON_TRANSPOSE,
                 rows, cols, rowstr[rows], &alpha,
                 descrA, d_mat, d_ranges, d_indir,
                 d_vec, &beta, d_out);
OnDemandEvaluated
  int cols      = Maximum of indir[0..ranges[rows]]
  double* d_mat = CudaRead of matrix[0..ranges[rows]]
  double* d_vec = CudaRead of vector[0..cols]
  int* d_ranges = CudaRead of ranges[0..rows+1]
  int* d_indir  = CudaRead of indir[0..rowstr[rows]]
  double* d_out = CudaWrite of output[0..rows]
PersistentVariables
  cusparseHandle_t handle
BeforeFirstExecution
  cusparseCreate(&handle);
AfterLastExecution
  cusparseDestroy(handle);
CppHeaderFiles
  #include <cuda_runtime.h>
  #include "cusparse_v2.h"

HARNESS mkl IMPLEMENTS spmv_csr
  sparse_matrix_t A;
  mkl_sparse_d_create_csr(&A, SPARSE_INDEX_BASE_ZERO,
                          rows, cols, ranges,
                          ranges+1, indir, matrix);
  struct matrix_descr C;
  C.type = SPARSE_MATRIX_TYPE_GENERAL;
  C.mode = SPARSE_FILL_MODE_LOWER;
  C.diag = SPARSE_DIAG_NON_UNIT;
  mkl_sparse_d_mv(SPARSE_OPERATION_NON_TRANSPOSE,
                  1.0, A, C, vector, 0.0, output);
OnDemandEvaluated
  int cols = Maximum of indir[0 .. ranges[rows]]
CppHeaderFiles
  #include "mkl.h"

READABLE CudaRead
  cudaMemcpy(out, in, sizeof(type_in)*size,
             cudaMemcpyHostToDevice);
BeforeFirstExecution
  cudaMalloc(&out, sizeof(type_in)*size);
AfterLastExecution
  cudaFree(out);

WRITEABLE CudaWrite
  cudaMemcpy(in, out, sizeof(type_in)*size,
             cudaMemcpyDeviceToHost);
BeforeFirstExecution
  cudaMalloc(&out, sizeof(type_in)*size);
AfterLastExecution
  cudaFree(out);

READABLE Maximum
  out = in[0];
  for(int i = 1; i < size; i++)
    out = in[i]>out?in[i]:out;
  out = out+1;
