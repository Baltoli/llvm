Export
Constraint Distributive
( {value} is add instruction and
  {sum1.value} is first argument of {value} and
  {sum2.value} is second argument of {value} and
  inherits SumChain at {sum1} and
  {product1.value} is the same as {sum1.last_factor} and
  inherits MulChain at {product1} and
  {product1.last_factor} is the same as {product2.last_factor} and
  inherits SumChain at {sum2} and
  {product2.value} is the same as {sum2.last_factor} and
  inherits MulChain at {product2})
End

Constraint SumChain
( {value} is an integer and
  {value} is the same as {results[0]} and
  ( ( {results[i]} is add instruction and
      inherits ArgumentsPermuted with {results[i]}   as {dst}
                                  and {results[i+1]} as {src1}
                                  and {factors[i]}   as {src2} and
      {last_factor} is an integer) or
    ( ( ( {results[i]} is an integer and
          {last_factor} is the same as {factors[i]}) or
        ( {results[i]} is unused and
          {factors[i]} is unused and
          {last_factor} is an integer)) and
      {results[i]} is the same as {factors[i]} and
      {results[i+1]} is unused)) for all i=0..N and
  {factors[N]} is unused)
for N=4 if not otherwise specified
End

Constraint MulChain
( {value} is an integer and
  {value} is the same as {results[0]} and
  ( ( {results[i]} is mul instruction and
      inherits ArgumentsPermuted with {results[i]}   as {dst}
                                  and {results[i+1]} as {src1}
                                  and {factors[i]}   as {src2} and
      {last_factor} is an integer) or
    ( ( ( {results[i]} is an integer and
          {last_factor} is the same as {factors[i]}) or
        ( {results[i]} is unused and
          {factors[i]} is unused and
          {last_factor} is an integer)) and
      {results[i]} is the same as {factors[i]} and
      {results[i+1]} is unused)) for all i=0..N and
  {factors[N]} is unused)
for N=4 if not otherwise specified
End

Constraint ArgumentsPermuted
( ( {src1} is first  argument of {dst} and
    {src2} is second argument of {dst}) or
  ( {src2} is first  argument of {dst} and
    {src1} is second argument of {dst}))
End

Export
Constraint HoistSelect
( {select} is select instruction and
  {input1} is second argument of {select} and
  {base} is first argument of {input1} and
  {input2} is third argument of {select} and
  {base} is first argument of {input2} and
  {input1} is gep instruction and
  {input2} is gep instruction)
End

Export
Constraint ForWithIteratorTest
( inherits Loop and
  {comparison} has data flow to {end} and
  {comparison} is icmp instruction and
  {iterator} has data flow to {comparison} and
  inherits InductionVar with {iterator}  as {old_ind}
                         and {increment} as {new_ind} and
  {increment} has data flow to {iterator} and
  {increment} is add instruction and
  {iterator} has data flow to {increment} and
  {iter_end} has data flow to {comparison} and
  inherits LocalConst with {iter_end} as {value}
                       and {begin}    as {begin} and
  {iter_begin} has data flow to {iterator} and
  inherits LocalConst with {iter_begin} as {value}
                       and {begin}      as {begin} and
  {iter_step} has data flow to {increment} and
  inherits LocalConst with {iter_step} as {value}
                       and {begin}     as {begin})
End

Constraint Loop
( inherits SESE and
  {end} has control flow to {begin})
End

Constraint InductionVar
{new_ind} reaches phi node {old_ind} from {end}
End

Constraint LocalConst
( ( {begin} is instruction and
    {value} is preexecution) or
  {value} strictly control flow dominates {begin} or
  ( {begin} is instruction and
    {value} is unused))
End

Constraint SESE
( {precursor} is branch instruction and
  {precursor} has control flow to {begin} and
  {end} is branch instruction and
  {end} has control flow to {successor} and
  {begin} control flow dominates {end} and
  {end} control flow post dominates {begin} and
  {precursor} strictly control flow dominates {begin} and
  {successor} strictly control flow post dominates {end} and
  all control flow from {begin} to {precursor} passes through {end} and
  all control flow from {successor} to {end} passes through {begin})
End
