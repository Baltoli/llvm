Constraint ComplexReductionsAndHistograms
( inherits For at {loop} and
  collect k 32
  ( inherits VectorRead
        with {loop.iterator} as {input_index}
         and {read_value[k]} as {value}
         and {loop}          as {scope}
                             at {read[k]}) and
  collect k 2
  ( inherits HistoPart
        with {loop.begin} as {begin}
         and {read}       as {read}
         and {loop}       as {loop}
         and {read_value} as {read_value}
                          at {histo[k]}) and
  collect k 2
  ( inherits ScalarPart
        with {loop.begin}    as {begin}
         and {loop}          as {loop}
         and {read_value}    as {read_value}
                             at {scalar[k]}) and
  {scalar[0].kernel.output} is not the
      same as {histo[0].update.store_instr} and
  collect i 2
  ( {histo[i].update.store_instr}
        is store instruction and
    {loop.begin} control flow
        dominates {histo[i].update.store_instr} and
    {loop.end} control flow post
        dominates {histo[i].update.store_instr}) and
  collect i 32
  ( inherits LocalFunctionCall
        with {loop.begin} as {begin}
         and {loop.end}   as {end} at {call[i]}) and
  collect i 32
  ( inherits LocalFunctionCall
        with {loop.begin} as {begin}
         and {loop.end}   as {end} at {call[i]} and
    {call[i].function} has attribute pure))
End

Constraint ScalarPart
( {kernel.output} reaches phi node
      {old_value} from {loop.end} and
  {loop.begin} control flow
      dominates {old_value} and
  {loop.end} strictly control flow
      post dominates {old_value} and
  {old_value} is not the same as {loop.iterator} and
  {kernel.output} reaches phi node
      {final_value} from {loop.end} and
  {final_value} strictly control flow
      post dominates {loop.end} and
  inherits KernelFunction
      with {loop} as {scope} at {kernel} and
  inherits Concat(N1=31,N2=1)
      with {read_value}   as {in1}
       and {old_value}    as {in2}
       and {kernel.input} as {out})
End

Constraint HistoPart
( inherits ConditionalReadModifyWrite
      with {indexkernel.output} as {address}
       and {loop}               as {loop} at {update} and
  inherits KernelFunction
      with {loop} as {scope} at {kernel} and
  {kernel.output} is the same as {update.new_value} and
  inherits KernelFunction
      with {loop}       as {scope}
       and {read_value} as {input} at {indexkernel} and
  ( {indexkernel.output} is not the same as
        {read[i].address} for all i=0..32) and
  inherits Concat(N1=31,N2=1)
      with {read_value}        as {in1}
       and {update.old_value}  as {in2}
       and {kernel.input}      as {out})
End

Constraint ConditionalReadModifyWrite
( {store_instr} is store instruction and
  inherits MaxOnceInScope
      with {store_instr} as {value}
       and {store_instr_after} as {value_after} at {loop} and
  {address} is second argument of {store_instr} and
  {address} is gep instruction and
  {address} is first argument of {old_value} and
  {old_value} is load instruction and
  {new_value} is first argument of {store_instr})
End

Constraint MaxOnceInScope
( {begin} control flow dominates {value} and
  {end} control flow post dominates {value} and
  {value} has control flow to {value_after} and
  all control flow from {value_after} to
      {value} passes through {end} and
  all control flow from {value_after} to
      {value} passes through {begin})
End

Constraint LocalFunctionCall
( {callsite} is call instruction and
  {function} is first argument of {callsite} and
  {begin} control flow dominates {callsite} and
  {end} control flow post dominates {callsite})
End

Constraint For
( inherits Loop and
  {increment} reaches phi node {iterator} from {end} and
  {increment} has data flow to {comparison} and
  {comparison} is icmp instruction and
  {comparison} has data flow to {end} and
  {increment} has data flow to {iterator} and
  {increment} is add instruction and
  {iterator} has data flow to {increment} and
  {iter_end} has data flow to {increment} and
  inherits LocalConst
      with {begin}    as {scope.begin}
       and {iter_end} as {value} and
  {iter_begin} has data flow to {increment} and
  inherits LocalConst
      with {begin}      as {scope.begin}
       and {iter_begin} as {value} and
  {iter_step} has data flow to {increment} and
  inherits LocalConst
      with {begin}     as {scope.begin}
       and {iter_step} as {value})
End

Constraint VectorRead
( {value} is load instruction and
  {address} is first argument of {value} and
  {base_pointer} is first argument of {address} and
  inherits LocalConst
      with {base_pointer} as {value} and
  {final_index} is second argument of {address} and
  ( ( {final_index} is add instruction and
      inherits ArgumentsPermuted
          with {final_index}   as {dst}
           and {strided_index} as {src1}
           and {offset}        as {src2} and
      inherits LocalConst
          with {offset} as {value} and
      {strided_index} is mul instruction and
      inherits ArgumentsPermuted
          with {strided_index} as {dst}
           and {input_index}   as {src1}
           and {stride}        as {src2} and
      inherits LocalConst
          with {stride} as {value}) or 
    ( {final_index} is mul instruction and
      inherits ArgumentsPermuted
          with {final_index} as {dst}
           and {input_index} as {src1}
           and {stride}      as {src2} and
      inherits LocalConst
          with {stride} as {value} and
      {strided_index} is the same as {final_index} and
      {offset} is unused) or 
    ( {final_index} is the same as {input_index} and
      {strided_index} is the same as {final_index} and
      {offset} is unused and
      {stride} is unused and
      {scope.begin} is instruction)))
End

Constraint KernelFunction
( collect i  4 ( {origins[i]} has control
                     flow to {scope.begin}) and
  collect i 24 ( inherits LocalConst
                     with {scope} as {scope}
                                  at {constants[i]} and
                 {constants[i].value}
                     is not a numeric constant and
                 {constants[i].value} has data
                     flow to {constants[i].use} and
                 {scope.begin} control flow
                     dominates {constants[i].use}) and
  collect i  8 ( {loop_carried[i].update} reaches
                     phi node {loop_carried[i].value}
                     from {scope.end} and
                 {scope.begin} control flow
                     dominates {loop_carried[i].value}) and

  all flow from {loop_carried[0..8].value} or any origin
      to any of {output} passes through at least one of
      {origins[0..4],constants[0..24].value,input[0..32]})
End

Constraint Concat
( if N1=1 then
    {out[0]} is the same as {in1}
  else
    {out[i]} is the same as {in1[i]} for all i=0..N1
  endif and
  if N2=1 then
    {out[N1+0]} is the same as {in2}
  else
    {out[N1+i]} is the same as {in2[i]} for all i=0..N1
  endif and
  if N3=1 then
    {out[N1+N2+0]} is the same as {in3}
  else
    {out[N1+N2+i]} is the same as {in3[i]} for all i=0..N3
  endif)
for N2=0 if not otherwise specified
for N3=0 if not otherwise specified
End
