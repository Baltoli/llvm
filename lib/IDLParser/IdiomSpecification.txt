Constraint Distributive
( opcode{value} = add
∧ {sum1.value} = {value}.args[0]
∧ {sum2.value} = {value}.args[1]
∧ include SumChain @ {sum1}
∧ {product1.value} = {sum1.last_factor}
∧ include MulChain @ {product1}
∧ {product1.last_factor} = {product2.last_factor}
∧ include SumChain @ {sum2}
∧ {product2.value} = {sum2.last_factor}
∧ include MulChain @ {product2})
End

Constraint SumChain
( data_type{value} = integer
∧ {value} = {results[0]}
∧ ( ( opcode{results[i]} = add
    ∧ include ArgumentsPermuted({results[i]}->{dst},{results[i+1]}->{src1},{factors[i]}->{src2})
    ∧ data_type{last_factor} = integer)
  ∨ ( ( ( data_type{results[i]} = integer
        ∧ {last_factor} = {factors[i]})
      ∨ ( {results[i]} is unused
        ∧ {factors[i]} is unused
        ∧ data_type{last_factor} = integer))
    ∧ {results[i]} = {factors[i]}
    ∧ {results[i+1]} is unused)) foreach i=0..N
∧ {factors[N]} is unused)
for N=4 if not otherwise specified
End

Constraint MulChain
( data_type{value} = integer
∧ {value} = {results[0]}
∧ ( ( opcode{results[i]} = mul
    ∧ include ArgumentsPermuted({results[i]}->{dst},{results[i+1]}->{src1},{factors[i]}->{src2})
    ∧ data_type{last_factor} = integer)
  ∨ ( ( ( data_type{results[i]} = integer
        ∧ {last_factor} = {factors[i]})
      ∨ ( {results[i]} is unused
        ∧ {factors[i]} is unused
        ∧ data_type{last_factor} = integer))
    ∧ {results[i]} = {factors[i]}
    ∧ {results[i+1]} is unused)) foreach i=0..N
∧ {factors[N]} is unused)
for N=4 if not otherwise specified
End

Constraint ArgumentsPermuted
( ( {src1} = {dst}.args[0]
  ∧ {src2} = {dst}.args[1])
∨ ( {src2} = {dst}.args[0]
  ∧ {src1} = {dst}.args[1]))
End

Constraint HoistSelect
( opcode{select} = select
∧ {input1} = {select}.args[1]
∧ {base} = {input1}.args[0]
∧ {input2} = {select}.args[2]
∧ {base} = {input2}.args[0]
∧ opcode{input1} = gep
∧ opcode{input2} = gep)
End

Constraint ForWithIteratorTest
( include Loop
∧ {increment} reaches phi node {iterator} from {body.end}
∧ {iterator} ∈ {comparison}.args
∧ opcode{comparison} = icmp
∧ {comparison} ∈ {end}.args
∧ {increment} ∈ {iterator}.args
∧ opcode{increment} = add
∧ {iterator} ∈ {increment}.args
∧ {iter_end} ∈ {comparison}.args
∧ include LocalConst({iter_end}->{value},{begin}->{begin})
∧ {iter_begin} ∈ {iterator}.args
∧ include LocalConst({iter_begin}->{value},{begin}->{begin})
∧ {iter_step} ∈ {increment}.args
∧ include LocalConst({iter_step}->{value},{begin}->{begin}))
End

Constraint Loop
( include SESE
∧ {body.begin} = {begin}
∧ {body.end} = {end}
∧ {body.precursor} = {precursor}
∧ {body.successor} = {successor}
∧ {end} ∈ {begin}.successors)
End

Constraint InductionVar
{new_ind} reaches phi node {old_ind} from {end}
End

Constraint LocalConst
( ( ir_type{begin} = instruction
  ∧ ir_type{value} = preexecution)
∨ strict_domination({value}, {begin})
∨ ( ir_type{begin} = instruction
  ∧ {value} is unused))
End

Constraint SESE
( opcode{precursor} = branch
∧ {precursor} ∈ {begin}.successors
∧ opcode{end} = branch
∧ {end} ∈ {successor}.successors
∧ domination({begin}, {end})
∧ post_domination({end}, {begin})
∧ strict_domination({precursor}, {begin})
∧ strict_post_domination({successor}, {end})
∧ all control flow from {begin} to {precursor} passes through {end}
∧ all control flow from {successor} to {end} passes through {begin})
End
