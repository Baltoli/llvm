Export
Constraint Experiment
( {begin} ∈ {precursor}.successors )
End

Export
Constraint SCoP
( include For @ {loop}
∧ include SideEffectFreePart({loop}->{scope})
                      @ {constraint_effects}
∧ include StructuredControlFlowPart({loop}->{scope})
                             @ {constraint_control}
∧ {constraint_memory.input[0]} = {loop.iterator}
∧ {constraint_memory.input[i+1]} =
      {constraint_control.forloop[i].iterator} foreach i=0..7
∧ include AffineMemoryAccessPart({loop}->{scope})
                           @ {constraint_memory}
∧ include AffineControlFlowPart({loop}->{scope},
             {constraint_memory.input}->{input})
                         @ {constraint_control})
End

Constraint SideEffectFreePart
( collect i 32 ( include LocalFunctionCall({scope}->{scope})
                                                @ {call[i]})
∧ collect i 32 ( include LocalFunctionCall({scope}->{scope})
                                                @ {call[i]}
               ∧ {call[i].function} has attribute pure))
End

Constraint StructuredControlFlowPart
( collect i 32 ( opcode{branch[i].value} = branch
               ∧ {branch[i].target1} =
                     {branch[i].value}.successors[0]
               ∧ {branch[i].target2} =
                     {branch[i].value}.successors[1]
               ∧ include LocalValue({scope}->{scope},
                          {branch[i].value}->{value}))
∧ collect i 16 ( include For @ {forloop[i]}
               ∧ domination({scope.begin},
                            {forloop[i].begin})
               ∧ strict_post_domination({scope.end},
                                        {forloop[i].end}))
∧ collect i 16 ( include IfBlock @ {ifblock[i]}
               ∧ domination({scope.begin},
                            {ifblock[i].precursor})
               ∧ strict_post_domination({scope.end},
                                        {ifblock[i].successor}))
∧ {forloop[0..16].end,ifblock[0..16].precursor}
      is the same set as {branch[0..32].value})
End

Constraint AffineMemoryAccessPart
( collect x 24 ( include MemoryAccess({scope}->{scope})
                                      @ {newaccess[x]}
               ∧ opcode{newaccess[x].pointer} = gep
               ∧ domination({scope.begin}, {newaccess[x].pointer})
               ∧ {newaffine[x].value} =
                     {newaccess[x].pointer}.args[1])
∧ collect x 24 ( include MemoryAccess({scope}->{scope})
                                      @ {newaccess[x]}
               ∧ opcode{newaccess[x].pointer} = gep
               ∧ domination({scope.begin}, {newaccess[x].pointer})
               ∧ {newaffine[x].value} =
                     {newaccess[x].pointer}.args[1]
               ∧ include AffineCalculation[M=8,N=6](
                          {scope}->{scope},
                          {input}->{input}) @ {newaffine[x]}
))
End

Constraint AffineControlFlowPart
( include AffineCalculation[M=8,N=1]({scope}->{scope},
                   {ifblock[i].compare_left}->{value},
                                     {input}->{input})
                            @{ifblock_affine_left[i]} foreach i=0..16
∧ include AffineCalculation[M=8,N=1]({scope}->{scope},
                  {ifblock[i].compare_right}->{value},
                                     {input}->{input})
                           @{ifblock_affine_right[i]} foreach i=0..16
∧ include AffineCalculation[M=8,N=1]({scope}->{scope},
                     {forloop[i].iter_begin}->{value},
                                     {input}->{input})
                           @{forloop_affine_begin[i]} foreach i=0..16
∧ include AffineCalculation[M=8,N=1]({scope}->{scope},
                       {forloop[i].iter_end}->{value},
                                     {input}->{input})
                             @{forloop_affine_end[i]} foreach i=0..16)
End

Constraint MemoryAccess
( ( ( opcode{access} = store
    ∧ {pointer} = {access}.args[1])
  ∨ ( opcode{access} = load
    ∧ {pointer} = {access}.args[0]))
∧ domination({scope.begin}, {access})
∧ post_domination({scope.end}, {access}))
End

Constraint AffineCalculation
if N=0 then
( ( include LocalConst
  ∧ ( data_type{input[j]} = integer
    ∨ {input[j]} is unused) foreach j=0..M)
∨ ( ( {value} = {input[i]}
    ∧ ir_type{scope.begin} = instruction
    ∧ ( data_type{input[j]} = integer
      ∨ {input[j]} is unused) foreach j=0..M) forany i=0..M))
else
( ( ( include AffineCalculation[M=M,N=0]
    ∧ {l.value} is unused
    ∧ {r.value} is unused)
  ∨ ( ( ( ( opcode{value} = add
          ∨ opcode{value} = sub)
        ∧ {l.value} = {value}.args[0]
        ∧ {r.value} = {value}.args[1])
      ∨ ( opcode{value} = select
        ∧ {l.value} = {value}.args[1]
        ∧ {r.value} = {value}.args[2])
      ∨ ( opcode{value} = mul
        ∧ include ArgumentsPermuted({l.value}->{src1},
                                    {r.value}->{src2},
                                      {value}->{dst})
        ∧ ir_type{l.value} = preexecution
        ∧ ir_type{r.value} = instruction))
    ∧ ir_type{scope.begin} = instruction
    ∧ domination({scope.begin}, {value})
    ∧ ( data_type{input[j]} = integer
      ∨ {input[j]} is unused) foreach j=0..M))
∧ include AffineCalculation[M=M,N=N-1]({input}->{input},
                                       {scope}->{scope}) @ {l}
∧ include AffineCalculation[M=M,N=N-1]({input}->{input},
                                       {scope}->{scope}) @ {r})
endif
End

Constraint LocalFunctionCall
( opcode{callsite} = call
∧ {function} = {callsite}.args[0]
∧ include LocalValue({callsite}->{value}))
End

Constraint IfBlock
( include PotentialSESE({truebegin}->{begin},{trueend}->{end})
∧ {truebegin} = {precursor}.successors[0]
∧ {falsebegin} = {precursor}.successors[1]
∧ include PotentialSESE({falsebegin}->{begin},{falseend}->{end})
∧ {trueend} ≠ {falseend}
∧ {condition} = {precursor}.args[0]
∧ opcode{condition} = icmp
∧ {compare_left} = {condition}.args[0]
∧ {compare_right} = {condition}.args[1])
End

Constraint PotentialSESE
( opcode{precursor} = branch
∧ {begin} ∈ {precursor}.successors
∧ opcode{end} = branch
∧ {successor} ∈ {end}.successors
∧ ( ( domination({begin}, {end})
    ∧ post_domination({end}, {begin})
    ∧ all control flow from {begin} to {precursor}
                        passes through {end}
    ∧ all control flow from {successor} to {end}
                            passes through {begin})
  ∨ ( {begin} = {end}
    ∧ {begin} ∈ {precursor}.successors
    ∧ {successor} ∈ {end}.successors)
  ∨ ( {precursor} = {end}
    ∧ {begin} = {successor})))
End

Constraint LocalValue
( domination({scope.begin}, {value})
∧ strict_post_domination({scope.end}, {value}))
End

Export
Constraint Distributive
( opcode{value} = add
∧ {sum1.value} = {value}.args[0]
∧ {sum2.value} = {value}.args[1]
∧ include SumChain @ {sum1}
∧ {product1.value} = {sum1.last_factor}
∧ include MulChain @ {product1}
∧ {product1.last_factor} = {product2.last_factor}
∧ include SumChain @ {sum2}
∧ {product2.value} = {sum2.last_factor}
∧ include MulChain @ {product2})
End

Constraint SumChain
( data_type{value} = integer
∧ {value} = {results[0]}
∧ ( ( opcode{results[i]} = add
    ∧ include ArgumentsPermuted({results[i]}->{dst},
                              {results[i+1]}->{src1},
                                {factors[i]}->{src2})
    ∧ data_type{last_factor} = integer)
  ∨ ( ( ( data_type{results[i]} = integer
        ∧ {last_factor} = {factors[i]})
      ∨ ( {results[i]} is unused
        ∧ {factors[i]} is unused
        ∧ data_type{last_factor} = integer))
    ∧ {results[i]} = {factors[i]}
    ∧ {results[i+1]} is unused)) foreach i=0..N
∧ {factors[N]} is unused)
for N=4 if not otherwise specified
End

Constraint MulChain
( data_type{value} = integer
∧ {value} = {results[0]}
∧ ( ( opcode{results[i]} = mul
    ∧ include ArgumentsPermuted({results[i]}->{dst},
                              {results[i+1]}->{src1},
                                {factors[i]}->{src2})
    ∧ data_type{last_factor} = integer)
  ∨ ( ( ( data_type{results[i]} = integer
        ∧ {last_factor} = {factors[i]})
      ∨ ( {results[i]} is unused
        ∧ {factors[i]} is unused
        ∧ data_type{last_factor} = integer))
    ∧ {results[i]} = {factors[i]}
    ∧ {results[i+1]} is unused)) foreach i=0..N
∧ {factors[N]} is unused)
for N=4 if not otherwise specified
End

Constraint ArgumentsPermuted
( ( {src1} = {dst}.args[0]
  ∧ {src2} = {dst}.args[1])
∨ ( {src2} = {dst}.args[0]
  ∧ {src1} = {dst}.args[1]))
End

Export
Constraint HoistSelect
( opcode{select} = select
∧ {input1} = {select}.args[1]
∧ {base} = {input1}.args[0]
∧ {input2} = {select}.args[2]
∧ {base} = {input2}.args[0]
∧ opcode{input1} = gep
∧ opcode{input2} = gep)
End

Constraint For
( include Loop
∧ {increment} -> {body.end} Φ {iterator}
∧ {increment} ∈ {comparison}.args
∧ opcode{comparison} = icmp
∧ {comparison} ∈ {end}.args
∧ {increment} ∈ {iterator}.args
∧ opcode{increment} = add
∧ {iterator} ∈ {increment}.args
∧ {iter_end} ∈ {comparison}.args
∧ include LocalConst({begin}->{scope.begin},
                  {iter_end}->{value})
∧ {iter_begin} ∈ {iterator}.args
∧ include LocalConst({begin}->{scope.begin},
                {iter_begin}->{value})
∧ {iter_step} ∈ {increment}.args
∧ include LocalConst({begin}->{scope.begin},
                 {iter_step}->{value}))
End

Export
Constraint ForWithIteratorTest
( include Loop
∧ {increment} -> {body.end} Φ {iterator}
∧ {iterator} ∈ {comparison}.args
∧ opcode{comparison} = icmp
∧ {comparison} ∈ {end}.args
∧ {increment} ∈ {iterator}.args
∧ opcode{increment} = add
∧ {iterator} ∈ {increment}.args
∧ {iter_end} ∈ {comparison}.args
∧ include LocalConst({begin}->{scope.begin},
                  {iter_end}->{value})
∧ {iter_begin} ∈ {iterator}.args
∧ include LocalConst({begin}->{scope.scope},
                {iter_begin}->{value})
∧ {iter_step} ∈ {increment}.args
∧ include LocalConst({begin}->{scope.scope},
                 {iter_step}->{value}))
End

Constraint Loop
( include SESE
∧ {begin} ∈ {end}.successors)
End

Constraint InductionVar
( {new_ind} -> {loop.end} Φ {old_ind}
∧ include LocalValue({loop}->{scope},
                  {old_ind}->{value}))
End

Constraint LocalConst
( ( ir_type{scope.begin} = instruction
  ∧ ir_type{value} = preexecution)
∨ strict_domination({value}, {scope.begin})
∨ ( {value} is unused
  ∧ ir_type{scope.begin} = instruction))
End

Constraint SESE
( opcode{precursor} = branch
∧ {begin} ∈ {precursor}.successors
∧ opcode{end} = branch
∧ {successor} ∈ {end}.successors
∧ domination({begin}, {end})
∧ post_domination({end}, {begin})
∧ strict_domination({precursor}, {begin})
∧ strict_post_domination({successor}, {end})
∧ all control flow from {begin} to {precursor}
         passes through {end}
∧ all control flow from {successor} to {end}
         passes through {begin})
End